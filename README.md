# はじめに

`fma()` 関数ではなく演算子 `+ - *` で数式に近い記法でソースを書きつつ FMA (fused multiply-add)
命令を使いたい、でもコンパイラが勝手に精度を変える最適化をする[^1]のは嫌といった要望に答える C++ クラスです。

[^1]: FP contract （短縮、契約ではなくて式を短縮するという意味）といって C 言語の仕様ではそういった最適化も認められているそうですが、そういうのは
off にして使うことを想定しています。

# 使い方

```C++
template <typename Float> class FusibleFloat;
using Ffloat = FusibleFloat<float>;
using Fdouble = FusibleFloat<double>;
```
のようにしてあるので、 `float/double` に代えて `Ffloat/Fdouble` 型で式を書くと勝手に `std::fma()` を呼んでくれます。元の
`float/double` に対しては[暗黙の型変換](FusibleFloat.hpp#L12-L14)を定義してあるので相互に代入や変換が可能です。なお、
`Ffloat/Fdouble` 以外の名前を使いたいときは `FUSIBLE_FLOAT_NO_TYPE_ALIASE` を定義した状態で include してください。

中でやっているのは、 `FusibleFloat` 型に対して `operator*()` が来たら `FusibleProduct`
として両辺の値を保存し、そこに `+` か `-` が来たら `std::fma()` を呼びそれ以外では単に `operator Float()` として掛けて丸めた値を返すというものです。

# 細かな挙動

元の `float/double` は勝手に FMA 化されたくないときに使うことになるので、 `Ffloat/Fdouble` との乗算になったときに
fuse の対象とするかが問題となります。悩んだのですが、
 1. 左辺値（名前のある普通の変数）の `float/double` とは fuse しない
 2. 右辺値（即値、関数の戻り値、式の値など）の `flaot/double` とは fuse する

をデフォルトの挙動としてあります（ `1.5f` のような数値を `Ffloat(1.5f)`
のように書かなければいけないルールだと式が煩雑になって本来の趣旨から離れるため）。これらは
`FUSIBLE_FLOAT_FUSE_LVALUE` や `FUSIBLE_FLOAT_NO_FUSE_RVALUE` を定義した状態で include
することで変えることもできます。なお、加減算のオペランド（ `std::fma()` の第3引数に相当）に関してはこのような型による区別は設けておらず、何が来ても
FMA になるようにしてあります。
FusibleProduct を相手に FMA 化を拒む型というのも考えることはできますがユースケースを思いつかなかったため。

# 曖昧さと対策

`Ffloat a, b, c, d` に対して
`a*b + c*d` という式はデフォルトでは曖昧性のエラーとなります。左の積と右の積のどちらかを丸めてからでないと
FMA にはできず、どちらを優先するとも区別がつかないからです。対処としては、単項演算子 `+` を用いて
`+(a*b) + c*d` とすると左の積については `operator float()` が呼ばれ乗算結果が丸められます。また、
`0.0f + a*b + c*d` のように書くと、厳密には FMA 2回になりますが同様の挙動となります。このように
 FusibleProduct 同士の足し引きで左側を優先して丸める挙動を、 FUSIBLE_FLOAT_ROUND_LEFT_PRODUCT
 を定義しておくことで有効化することもできます。
 
なお `a*b*c + d` のような式では `a*b` が先に評価されこれが `float &&` となって `c` と fuse し、
`fmaf(a*b, c, d)` のような挙動となります。

# [test.cpp](test.cpp) について

網羅的なテストという程にはなっていません。
`std::fma(a, b, -a*b)` のような計算をすると、 `a*b` の計算で発生した丸め誤差を取り出すことができます。これを利用して、
FMA 化されなかった場合は 0 に、された場合には小さな値が表示されるようになっています。実行結果は
```bash
test1
0.000000e+00
-3.576279e-09
0.000000e+00
-3.576279e-09
0.000000e+00
-3.576279e-09
test2
3.576279e-09
-3.576279e-09
3.576279e-09
3.576279e-09
```
となっていますがコンパイラや FPU によっては異なる可能性もあります。

# TODO

ライセンスの追加とこの説明書の英語版
